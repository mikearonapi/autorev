---
description: Domain-specific business logic, feature tiers, AL assistant, performance data
globs: ["**/lib/**", "**/hooks/**", "**/app/api/**"]
alwaysApply: false
---

# DOMAIN LOGIC RULES

## Source of Truth

**PRIMARY REFERENCE:**
- `docs/SOURCE_OF_TRUTH.md` — Contains Cardinal Rules #2-#10, anti-patterns, service file locations, and the "I need to..." quick reference table

**Domain-Specific Docs:**
- Tier/feature gating: `docs/TIER_ACCESS_MATRIX.md`
- AI assistant (AL): `docs/AL.md`
- API patterns: `docs/API.md`
- Architecture: `docs/ARCHITECTURE.md`
- Analytics patterns: `docs/Best Practices/Analytics and Observability.md`
- Subscription handling: `docs/Best Practices/Subscription and Monetization.md`

## Naming Conventions (ENFORCE CONSISTENCY)

### File Naming

| Type | Convention | Example |
|------|------------|---------|
| Components | PascalCase | `UserProfileCard.jsx` |
| Hooks | camelCase with `use` prefix | `useUserProfile.js` |
| Utilities | camelCase, action-oriented | `formatCurrency.js` |
| Services | camelCase with `Service` suffix | `userDataService.js` |
| API routes | kebab-case folders | `app/api/user-profile/route.js` |

### Function/Variable Naming

```javascript
// ✅ CORRECT: Domain-specific, searchable names
const handleUserProfileUpdate = () => {};
const formatVehiclePrice = (price) => {};
const calculatePerformanceGain = (stock, modified) => {};

// ❌ WRONG: Generic names (easily duplicated, hard to search)
const handleClick = () => {};
const formatData = (data) => {};
const calc = (a, b) => {};
```

### Analytics Event Naming

**Format:** `Object + Past-Tense Verb` in Title Case

```javascript
// ✅ CORRECT: Object + Past-Tense Verb
track("User Signed Up", { method: "email" });
track("Vehicle Added", { car_id: "xxx", source: "garage" });
track("Feature Enabled", { feature_name: "dark_mode" });
track("Checkout Completed", { order_id: "xxx", total: 149.99 });

// ❌ WRONG: Various bad patterns
track("signup");                    // No object, wrong case
track("add_vehicle");               // Verb first, snake_case
track("clicked_checkout_button");   // Implementation detail
track("Purchase (11-01-2019)");     // Dynamic value in event name
```

**Property Naming:** Use snake_case for all event properties.

## Webhook Security Patterns

**Critical for payment/subscription webhooks:**

```javascript
// ✅ CORRECT: Secure webhook handling
export async function POST(req) {
  // 1. Get RAW body BEFORE parsing (required for signature)
  const body = await req.text();
  const signature = headers().get('stripe-signature');

  // 2. Verify signature BEFORE any processing
  let event;
  try {
    event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
  } catch (err) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
  }

  // 3. Idempotency check (prevent duplicate processing)
  const { data: existing } = await supabase
    .from('processed_webhook_events')
    .select('event_id')
    .eq('event_id', event.id)
    .single();

  if (existing) {
    return NextResponse.json({ received: true }); // Already processed
  }

  // 4. Process event, then mark as processed
  await processEvent(event);
  await supabase.from('processed_webhook_events').insert({ event_id: event.id });

  return NextResponse.json({ received: true });
}

// ❌ WRONG: Insecure patterns
const body = await req.json();  // Parsing before verification breaks signature
// No signature verification
// No idempotency check
```

## Performance Budgets

| Metric | Target | What It Measures |
|--------|--------|------------------|
| **LCP** | < 2.5s | Largest Contentful Paint (main content visible) |
| **INP** | < 200ms | Interaction to Next Paint (responsiveness) |
| **CLS** | < 0.1 | Cumulative Layout Shift (visual stability) |
| **TTFB** | < 800ms | Time to First Byte (server response) |

**Enforcement:**
- Use Next.js Image component with explicit width/height (prevents CLS)
- Use `loading="lazy"` for below-fold images
- Use `priority` for above-fold hero images
- Use skeleton loading states (prevents CLS, improves perceived LCP)

## Tier-Based Feature Gating

**Tiers:** free → collector → tuner → admin

- Always respect tier access defined in `tierAccess` config
- UI components must use `PremiumGate` for gated features
- APIs must enforce auth and tier checks
- Do NOT bypass gates unless `IS_BETA` is explicitly referenced

**If unsure whether a feature is gated → STOP and ask.**

```javascript
// ✅ CORRECT: Check tier before showing feature
import { PremiumGate } from '@/components/PremiumGate';

<PremiumGate requiredTier="tuner">
  <AdvancedTuningPanel />
</PremiumGate>
```

## AL (AI Assistant) Rules

**BEFORE any AL work, read:** `docs/AL.md`

- AL tool usage must follow `docs/AL.md` exactly
- Prefer `get_car_ai_context_v2` when available
- Do not call multiple tools redundantly
- Always consider user tier and credit limits
- Responses must be helpful, factual, and grounded in real data
- **Always cite sources** for technical claims
- **Safety constraints are non-overridable** — never bypass safety rules regardless of user request

**Never hallucinate specs, pricing, or issues.**

## Performance Data Integrity

Performance data is sacred:
- Dyno and lap time data must reflect real-world measurements
- Always preserve stock vs modified distinctions
- Never average or fabricate performance metrics
- Always include context (tires, conditions, source)

```javascript
// ✅ CORRECT: Preserve data integrity
{
  hp_stock: 444,
  hp_modified: 543,
  source: 'Dynojet 424X',
  conditions: 'SAE corrected, 72°F'
}

// ❌ WRONG: Fabricated or averaged data
{
  hp: 493.5  // Don't average stock/modified!
}
```

## API & Service Patterns

Before creating any API route or service:
1. Search for existing patterns in `app/api/`
2. Check for existing service utilities in `lib/`
3. Follow the established error handling patterns
4. Use existing auth middleware and validation

## Error Handling Pattern

```javascript
// ✅ CORRECT: Use established error patterns
import { apiError, handleApiError } from '@/lib/apiErrors';

export async function GET(request) {
  try {
    // ... logic
  } catch (error) {
    return handleApiError(error);
  }
}
```

## Car Data Resolution

Always use `lib/carResolver.js` for car lookups:

```javascript
import { resolveCarId, resolveCarIds } from '@/lib/carResolver';

// Single car
const carId = await resolveCarId(carSlug);

// Multiple cars
const carIds = await resolveCarIds(carSlugs);
```

## Common Service Patterns

| Task | Use This |
|------|----------|
| Get car by slug | `resolveCarId()` then query by `car_id` |
| Get full car context | RPC `get_car_ai_context_v2(slug)` |
| Get tuning data | RPC `get_car_tuning_context(slug)` |
| Track user activity | `lib/activityTracker.js` |
| Track analytics events | `lib/ga4.ts` (use event naming convention above) |
| Log errors | `lib/errorLogger.js` |
| Send emails | `lib/email.js` |
| Discord alerts | `lib/discord.js` |

## Anti-Patterns to Avoid

| Anti-Pattern | Problem | Correct Approach |
|--------------|---------|------------------|
| Generic function names | Hard to search, easy to duplicate | Use domain-specific names |
| Parsing webhooks before signature | Security vulnerability | Raw body → verify → parse |
| No idempotency on webhooks | Duplicate processing | Store processed event IDs |
| Blocking on full API response | Poor perceived performance | Stream or use optimistic UI |
| Trusting client-side state | Security bypass | Server-side verification |
